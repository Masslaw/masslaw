# Gremlin Lingering Processes Causing The Container To Not Be Released

## Issue

Gremlin's created background processes, are lingering and causing the container to not be released.
Making the overall processing job to stay running until timeout - meaning a waste of resources and time, in addition
the timeout is considered a failure and the job is marked as failed - leading to the overall case-file processing pipeline to fail.

## Desired Alternative

When the application finishes an execution - regardless of the outcome, the container should be released.
This means, all running threads and background processes should be terminated.

> The following code was included and was running at application shut down, still the processes that belonged to the gremlin actions were not terminated.
```python
class ApplicationExecution:
    
    # ...
    
    def __terminate_all_threads(self):
        main_thread = threading.current_thread()
        for thread in threading.enumerate():
            if thread is main_thread: continue
            logger.log(logging.INFO, f"Terminating Thread {common_formats.value(thread.name)}")
            try: thread.join(timeout=1)
            except RuntimeError: pass
            if not thread.is_alive(): continue
            if hasattr(thread, 'ident'):
                thread_id = thread.ident
                res = ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(thread_id), ctypes.py_object(SystemExit))
                if res > 1:
                    ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, 0)
                    logger.log(logging.CRITICAL, f"Failed to terminate thread {thread.name}")
        logger.positive("All threads terminated successfully")
```

The lingering process was a result of gremlin failing to close the connections it had open.
Closing the connections was done through this code:
```python
class NeptuneConnection:
    def close_connection(self):
        if not self._connected():
            self._connection = None
            return
        close_connection_thread = threading.Thread(target=self._connection.close)
        close_connection_thread.start()
        close_connection_thread.join(timeout=5)
        del self._connection
        self._connection = None
        logger.positive("Connection Closed")
```

Seemingly, this should work as it times out the attempt to close the connection after 5 seconds, then forcefully shuts it down and proceeds.

The issue occures due to the way gremlinpython performs the connection close - it creates sub-processes of its own that when failing to 
close the connections - are lingering and keeping the application from proceeding to its own termination.

## Solution

The solution was to avoid calling the gremlinpython's close connection method directly, instead, the application termination signal (`sys.exit(...)`)
forcefully causes the connection to be shut down, without any action needed from gremlin's side.
